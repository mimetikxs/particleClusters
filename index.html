<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Playground</title>
        <link rel="stylesheet" href="css/app.css">
    </head>
    <body>

        <div id="layer-gl"></div>

        <p id="title">PARTICLE CLUSTER EDITOR</p>

        <script src="lib/jquery-1.12.0.min.js"></script>
        <script src="lib/dat.gui.min.js"></script>
		<script src="lib/three.min.js"></script>
        <script src="lib/Stats.js"></script>
        <script src="lib/dat.gui.min.js"></script>

        <script src="src/App.js"></script>
        <script src="src/Particle.js"></script>
        <script src="src/Constraint.js"></script>
        <script src="src/Spring.js"></script>
        <script src="src/SpringMinDist.js"></script>
        <script src="src/Attraction.js"></script>
        <script src="src/Physics.js"></script>

        <script>


        // TODO: hacer que los clusters "florezcan" cuando el raton se acerca a ellos.

            var scene, camera, renderer;

            // cluter physics model
            var physics,
                sphereConstraint,
                centralParticle,
                particles = [],
                interactiveParticles = [],
                radialSprings = [],
                surfaceSprings = [],
                centerAttractions = [],
                mouseAttractions = [],

                backgroundColor,

                sprite, sprite2,

                // geometryPoints,
                geometriesPoints = [], points, materialPoints,
                geometryLines, lines, materialLines,
                circleGeometry, circle, circleMaterial;

            var geometryMouseLines, mouseLines;

            var mouseParticle,
                sceneWidth, sceneHeight;

            var stats;

            var gui, guiParameters;

            init();
            animate();

            function init() {

                var $holder = $('#layer-gl');

                sceneWidth = $holder.width();
                sceneHeight = $holder.height();

                scene = new THREE.Scene();

                //camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
                camera = new THREE.OrthographicCamera( sceneWidth / -2, sceneWidth / 2, sceneHeight / 2, sceneHeight / -2, 1, 1000 );
                camera.position.z = 500;

                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( sceneWidth, sceneHeight );
                // renderer.setClearColor( 0x000000 );

                backgroundColor = new THREE.Color( 0xF2F3F4 );
                renderer.setClearColor( backgroundColor.getHex() );

		        $holder.append( $(renderer.domElement) );

                buildGui();

                buildCluster();

                // stats
                stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
                document.body.appendChild( stats.domElement );

                document.addEventListener( 'mousemove', onDocumentMouseMove, false );

            }

            function animate() {

                requestAnimationFrame( animate );

                stats.begin();

                physics.update();

                for (var i = 0; i < geometriesPoints.length; i++) geometriesPoints[ i ].verticesNeedUpdate = true;
                geometryLines.verticesNeedUpdate = true;
                geometryMouseLines.verticesNeedUpdate = true;

                updateMouseInteraction();

                renderer.render( scene, camera );

                stats.end();

            }


            function buildGui() {
                // gui
                guiParameters = {
                    cluster_radius     : 200.0,
                    radial_strength    : 1.0, //2.0,
                    surface_strength   : 0.00005,
                    central_attraction : 0,//1, //-300.0,
                    gravity           : 0, //2.0,
                    mouse_attraction   : 0, //100.0,
                    background_darkness : 0.0
                }
                gui = new dat.GUI( {width:350});

                gui.add( guiParameters, 'cluster_radius', 10.0, 250.0 ).onChange( onClusterRadius );
                gui.add( guiParameters, 'radial_strength', 0.00001, 1.0 ).onChange( onRadialStrength );
                gui.add( guiParameters, 'surface_strength', 0.0, 0.05 ).onChange( onSurfaceStrength );
                gui.add( guiParameters, 'central_attraction', -1000.0, 1000.0 ).onChange( onCentralRepulsion );
                gui.add( guiParameters, 'gravity', 0.0, 10.0 ).onChange( onGravity );
                gui.add( guiParameters, 'mouse_attraction', -500.0, 500.0 ).onChange( onMouseAttraction );
                gui.add( guiParameters, 'background_darkness', 0.0, 1.0 ).onChange( onBackgroundDarkness );
            }

            function buildCluster() {

                // ---------------------------
                // physics model

                physics = new APP.Physics();

                centralParticle = new APP.Particle(0, 0, 0);
                centralParticle.isFixed = true;

                var clusterCenter = new THREE.Vector3();

                sphereConstraint = new APP.Constraint( clusterCenter, guiParameters.cluster_radius );

                // create particles at random positions within the constraining sphere
                var spanRaadius = 20;
                for ( var i = 0; i < 50; i++ ) {
                    var x = Math.random() * (spanRaadius*2) - spanRaadius,
                        y = Math.random() * (spanRaadius*2) - spanRaadius,
                        z = Math.random() * spanRaadius;

                    particle = new APP.Particle( x, y, z );
                    //particle.constraints.push( sphereConstraint );

                    particles.push( particle );
                    physics.addParticle( particle );
                }

                // connect the particles with the center of the constraining sphere
                for ( var i = 0; i < particles.length; i++ ) {
                    var spring = new APP.Spring( centralParticle, particles[ i ], guiParameters.cluster_radius );
                    spring.strength = guiParameters.radial_strength;

                    radialSprings.push( spring );
                    physics.addSpring( spring );
                }

                // connect particles between them to avoid collisions
                var i, j, a, b;

    			for ( i=0; i<particles.length-1; ++i ) {
    				for ( j=i+1; j<particles.length; ++j ) {
    					a = particles[ i ];
    					b = particles[ j ];

    					var spring = new APP.SpringMinDist( a, b );
                        spring.setLength( guiParameters.cluster_radius );
                        // dirty test: interactive clusters (the first 4) have stroger springs to avoid overlaping
                        // spring.strength = Math.random() * 0.005;
                        spring.percent = ( i < 8 && j < 4) ? 1.0 : Math.random();
                        spring.strength = guiParameters.surface_strength;

                        surfaceSprings.push( spring )
    					physics.addSpring( spring );
    				}
    			}

                // create a particle for the mouse
                mouseParticle = new APP.Particle(0, 0, 0);
                mouseParticle.isFixed = true;

                //testing
                // particles[0].isFixed = true;

                physics.addParticle( mouseParticle );

                // Attraction to mouse
                for ( var i = 0; i < particles.length; i++ ) {
                    var attraction = new APP.Attraction( mouseParticle, particles[i], guiParameters.mouse_attraction );
                    attraction.distMin = 30;
                    attraction.distMax = guiParameters.cluster_radius;

                    mouseAttractions.push( attraction );
                    physics.attractions.push( attraction );
                }

                // repulsion/attraction to center
                for ( var i = 0; i < particles.length; i++ ) {
                    var attraction = new APP.Attraction( centralParticle, particles[i], guiParameters.central_attraction );
                    attraction.distMin = 50;
                    attraction.distMax = guiParameters.cluster_radius;

                    centerAttractions.push( attraction );
                    physics.attractions.push( attraction );
                }

                // --------------------------
                // points view
                // each material is applied to a THREE.Points object
                // TODO: use shaders to optimize variations in size and color

                sprite1 = new THREE.TextureLoader().load( "assets/circle-fill.png" );
                sprite2 = new THREE.TextureLoader().load( "assets/circle-marked.png" );

                var styles = [
					[ 0xF39C12, 30, sprite2 ],
                    [ 0xE74C3C, 12, sprite1 ],
                    [ 0x8E44AD, 18, sprite1 ],
                    [ 0x3498DB, 15, sprite1 ],
                    [ 0x1ABC9C, 6, sprite1 ],
				];

                var numParticles = particles.length,
                    numStyles = styles.length,
                    numParticlesPerStyle = Math.round( numParticles / numStyles ),
                    i, pointCount, pointIndex = 0, color, size, sprite,
                    materialPoints, geomPoints, points;

                for ( i = 0; i < numStyles; i++ ) {
                    color = styles[ i ][ 0 ];
                    size = styles[ i ][ 1 ];
                    sprite = styles[ i ][ 2 ];

                    //materialPoints = new THREE.PointsMaterial( { size: size, sizeAttenuation: false } );
                    materialPoints = new THREE.PointsMaterial( { size: size, sizeAttenuation: false, map: sprite, alphaTest: 0.5, transparent: true } );
                    materialPoints.color.setHex( color );

                    geomPoints = new THREE.Geometry();
                    pointCount = 0;
                    while ( pointCount < numParticlesPerStyle  &&  pointIndex < numParticles-1 ) {
                        pointIndex = i * numParticlesPerStyle + pointCount;

                        geomPoints.vertices.push( particles[ pointIndex ].pos );
                        pointCount++;
                    }

                    points = new THREE.Points( geomPoints, materialPoints );

                    geometriesPoints.push( geomPoints );

                    scene.add( points );
                }

                // --------------------------
                // lines view

                materialLines = new THREE.LineBasicMaterial( { color: 0xdddddd, linewidth: 1, transparent: true, opacity: 0.2 } );
                materialLines.visible = true;

                geometryLines = new THREE.Geometry();
                for ( var i = 0; i < particles.length; i++ ) {
                    geometryLines.vertices.push( centralParticle.pos, particles[ i ].pos );
                }

                lines = new THREE.LineSegments( geometryLines, materialLines );

                scene.add( lines );

                // --------------------------
                // central circle

                // var radius = 50;
                // var segments = 32;
                //
                // circleMaterial = new THREE.MeshBasicMaterial( { color: 0xF39C12 } );
                // circleMaterial.color.offsetHSL(0,0,-0.2);
                //
                // circleGeometry = new THREE.CircleGeometry( radius, segments );
                //
                // circle = new THREE.Mesh( circleGeometry, circleMaterial );
                // scene.add( circle );

                // --------------------------
                // mouse lines view

                geometryMouseLines = new THREE.Geometry();

                for (var i = 0; i < physics.attractions.length; i++) {
                    var attraction = physics.attractions[i];

                    geometryMouseLines.vertices.push( attraction.a.pos, attraction.b.pos )
                }

                //mouseLines = new THREE.LineSegments( geometryMouseLines, materialLines );

                //scene.add( mouseLines );

            }

            function onDocumentMouseMove( event ) {

				mouseParticle.pos.x = event.clientX - sceneWidth/2;
				mouseParticle.pos.y = sceneHeight/2 - event.clientY;

			}

            function updateMouseInteraction() {

                var attractions = physics.attractions;

                // for ( var i = 0; i < attractions.length; i++ ) {
                // }


                // testing
                //particles[0].pos.copy(mouseParticle.pos)
            }

            function onClusterRadius( value ) {

                var radius = value;

                sphereConstraint.radius = radius;

                for ( var i = 0; i < radialSprings.length; i++ ) {
                    radialSprings[i].restLength = radius;
                }

                for ( var i = 0; i < surfaceSprings.length; i++ ) {
                    surfaceSprings[i].setLength( radius );
                }

                for ( var i = 0; i < mouseAttractions.length; i++ ) {
                    mouseAttractions[i].distMax = radius;
                }

                for ( var i = 0; i < centerAttractions.length; i++ ) {
                    centerAttractions[i].distMax = radius;
                }

            }

            function onRadialStrength( value ) {

                for ( var i = 0; i < radialSprings.length; i++ ) {
                    radialSprings[i].strength = value;
                }

            }

            function onSurfaceStrength( value ) {

                for ( var i = 0; i < surfaceSprings.length; i++ ) {
                    surfaceSprings[i].strength = value;
                }

            }

            function onCentralRepulsion( value ) {

                for ( var i = 0; i < centerAttractions.length; i++ ) {
                    centerAttractions[i].strength = value;
                }

            }

            function onGravity( value ) {

                physics.gravity.z = value;

            }

            function onMouseAttraction( value ) {

                for ( var i = 0; i < mouseAttractions.length; i++ ) {
                    mouseAttractions[i].strength = value;
                }

            }

            function onBackgroundDarkness( value ) {

                var color = new THREE.Color( 0xF2F3F4 ).lerp ( new THREE.Color( 0.12,0.11,0.15 ), value )
                renderer.setClearColor( color.getHex() );

            }

        </script>

    </body>
</html>
